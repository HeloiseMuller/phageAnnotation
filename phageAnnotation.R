#!/usr/bin/env Rscript
if(!"optparse" %in% installed.packages()[, "Package"])install.packages("optparse")
library(optparse)

print("Viral Annotation version v.0.1")

#Future development: give more options to -f so people have options for filtering

option_list = list(
  make_option(c("-c", "--checkV"), type="character", default=NULL,  
              help="output generated by checkV", metavar="character"),
  make_option(c("-v", "--virsorter"), type="character", default=NULL, 
              help="output generated by the second run of Virsorter2", metavar="character"),
  make_option(c("-w", "--wirsorter"), type="character", default=NULL, 
              help="optional, output generated by the first run of Virsorter2", metavar="character"),
  make_option(c("-l", "--len"), type="numeric", default=5000, 
              help="filter out phage sequences shorter than this threshold [default = 5000]", metavar="numeric"),
  make_option(c("-f", "--filtering"), type="numeric", default=0, 
              help="optional, whether should apply tuning removal filters [default = 0 to not apply; 1 applies them]", metavar="numeric"),
  make_option(c("-o", "--out"), type="character", default=NULL, 
              help="optional, path where to save the outputs. If none is providing, outputs will be save at the same location as checkV file", metavar="character")
); 

opt_parser = OptionParser(option_list=option_list);
opt = parse_args(opt_parser);

#Charge those library only now so does not print anything about them when one just want to print the help
packages <- c("data.table", "dplyr", "stringi")
newPackages <- packages[!(packages %in% installed.packages()[,"Package"])]
if(length(newPackages)) install.packages(newPackages)

library(data.table)
library(dplyr)
library(stringi)

#######################################

#Function I need as soon as arguments
splitToColumns <- function(vect,
                           split, #pattern at which we want to split the vector
                           maxColumns, #optional, stop splitting once reach this number of columns --> the last column contains everything that left
                           columns, #optional: return just this column
                           empty = "",
                           mode = "character") {
  # split a character vector and returns a matrix. Characters are split upon each
  # occurence of the split argument (a character of length one). empty defines
  # what the empty cell should be, and mode is the mode of the returned matrix.
  # This basically does what stri_split_fixed() does, but may sometime be more
  # convenient or faster
  
  vect <- as.character(vect)
  nc <- stri_length(split)
  out <- NULL
  
  if (!missing(maxColumns)) {
    maxCols <- as.integer(maxColumns)
  } else {
    maxCols <- NA
  }
  
  if (!missing(columns)) {
    cols <- as.integer(columns)
    cols <- cols[cols >= 1]
    out <- matrix(empty, length(vect), length(cols))
  } else {
    cols <- 1:1000
  }
  
  col <- 1
  
  repeat {
    temp <- vect
    pos <- as.vector(regexpr(split, vect, fixed = T)) - 1
    f <- pos >= 0
    temp[f] <- stri_sub(vect[f], 0, pos[f])
    
    if (!missing(columns)) {
      if (col %in% cols) {
        out[, match(col, cols)] <- temp
      }
    } else {
      out <- cbind(out, temp)
    }
    
    col <- col + 1
    
    if (col > max(cols) | !any(f)) {
      break
    }
    
    vect[f] <- stri_sub(vect[f], pos[f] + nc + 1, stri_length(vect[f]))
    vect[!f] <- empty
    
    if (!is.na(maxCols)){
      if (col == maxCols){
        out <- cbind(out, vect[f])
        break
      }
    }
  }
  
  if (ncol(out) == 1) {
    out <- as.vector(out)
  }
  
  storage.mode(out) <- mode
  
  out
}

#Proceed to verification regarding arguments

if(is.null(opt$checkV)){
  print_help(opt_parser)
  stop("File generated by checkV was provided not", call.=FALSE)
} else {
  file_checkV <- opt$checkV
}

if(is.null(opt$virsorter)){
  print_help(opt_parser)
  stop("File generated by second round of virsorter2 was not provided", call.=FALSE)
} else {
  file_virsorter <- opt$virsorter
}

if(is.null(opt$wirsorter)){
  coord <-  F
  print("File generated by first round of virsorter2 was not provided, so coordinates of phage sequences in the genome will not be computed")
} else {
  coord <-  T
  file_virsorter_1stRound <- opt$wirsorter
}

if(is.null(opt$out)){
  out <-  dirname(opt$virsorter)
} else {
  out <- opt$out
}
dir.create(paste0(out, "/filtering/"))
outF <- paste0(out, "/filtering/") 
print(paste0("Outputs will be saved at: ", outF, "/"))


##########################

#Functions needed by the pipeline

#Function to get coordinates phage
getCoordPhage_f <- function(dt){
  contig = sub("[|][|].*", "", dt$contig_id)
  if(dt$provirus=="No"){
    out <- data.table(assembly = dt$assembly, contigVir = dt$contig_id, contig = contig, length_VS1 = dt$contig_length, 
                      start_checkV = NA, end_checkV = NA, trimmed = "No", 
                      tot_genes_checkV = dt$total_genes, viral_genes_checkV = dt$viral_genes, host_genes_checkV = dt$host_genes, n = "")
  } else {
    regions <- splitToColumns(dt$region_types, ",")
    viral_indice = which(regions=="viral")
    coords <- splitToColumns(dt$region_coords_bp, ",")
    coords_viral = coords[viral_indice]
    start = as.numeric(sub("-.*", "", coords_viral))
    end = as.numeric(sub(".*-", "", coords_viral))
    out <- data.table(assembly = dt$assembly, contigVir = dt$contig_id,  contig = contig, length_VS1 = dt$contig_length,
                      start_checkV = start, end_checkV = end, trimmed = "Yes", 
                      tot_genes_checkV = dt$total_genes, viral_genes_checkV = dt$viral_genes, host_genes_checkV = dt$host_genes)
    out$n = 1:nrow(out)
  }
  return(out)
}
#If host in between viral, will output two lines
#To note, sometimes checkV didn't find viral nor host so NA  in region_types (and other region_), so my function also return NA for start_checkV and end_checkV


#FUNCTION TO ASSESS QUALITY
#This function calculate many scores, out automatic filtering does not use all of them
quality_phage_f <- function(dt){ 
  
  #What phage pass quality according to Sullivan?
  dt[, keep_tmp := ifelse(viral_genes_checkV>=1, "keep1",
                          ifelse(viral_genes_checkV==0 & (host_genes_checkV==0 | max_score>=0.95 | hallmark>2), "keep2", "others"))]
  dt[, keep_Sullivan := ifelse(keep_tmp!="others", keep_tmp,
                                 ifelse(keep_tmp=="others" & viral_genes_checkV==0 & host_genes_checkV==1 & length>=10000, "manual", "discard"))]
  dt <- dt[, -"keep_tmp"]
  
  #What phages pass according to Hegarty et al.?
  dt[, Hegarty_single := ifelse(max_score>=0.95, 1, 0.5)]

  dt[, Hegarty_addition_1 := ifelse(percUnknown>=75 & length<50000, 0.5, 0)]  
  dt[, Hegarty_addition_2:=ifelse(viral_genes_checkV>=50 | viral>50, 0.5, 0)]
  dt[, Hegarty_addition_3:=ifelse(hallmark>=3, 1, 0)]
  dt[, Hegarty_addition_all := Hegarty_addition_1+Hegarty_addition_2+Hegarty_addition_3]
  
  dt[, Hegarty_removal_1 := ifelse(viral_genes_checkV==0 & host_genes_checkV>=1, -1, 0)]
  dt[, Hegarty_removal_2 := ifelse(3*viral_genes_checkV<=host_genes_checkV & trimmed=="No", -1, 0)]
  dt[, Hegarty_removal_3 := ifelse(host_genes_checkV>50 & trimmed=="No", -3, 0)]
  dt[, Hegarty_removal_4 := ifelse(length>50000 & hallmark<=1, -3, 0)]

  
  dt[, Hegarty_removal_all := Hegarty_removal_1+Hegarty_removal_2+Hegarty_removal_3+Hegarty_removal_4]
  dt[, Hegarty_removal_AND_single := Hegarty_single+Hegarty_removal_all]
  dt[, Hegarty_sum := Hegarty_single+Hegarty_addition_all+Hegarty_removal_all]
  
  return(dt)
}

######################
#Read the two mandatory inputs files

print("Reading checkV...")
checkV <- fread(file_checkV, header = F,
                col.names = c("contig_id", "contig_length","total_genes", "viral_genes", "host_genes", "provirus", 
                              "proviral_length", "host_length", "region_types", "region_lengths",  "region_coords_bp", "region_coords_genes",
                              "region_viral_genes","region_host_genes", "assembly"))
checkV$ID = 1:nrow(checkV)

checkV_clean <- rbindlist(lapply(split(checkV, checkV$ID), getCoordPhage_f)) 
#checkV_clean[, seqname:=ifelse(n=="", paste0(assembly, ":", contigVir), paste0(assembly, ":", contigVir, "_", n))]
checkV_clean[, seqname:=ifelse(n=="", contigVir, paste0(contigVir, "_", n))]
checkV_clean[, percUnknown:=(tot_genes_checkV-viral_genes_checkV-host_genes_checkV)*100/tot_genes_checkV]
checkV_clean[, percViral:=viral_genes_checkV*100/tot_genes_checkV]

print("Reading VS2 from round 2...")
VS2 <- fread(file_virsorter, 
             col.names = c("seqname", "dsDNAphage", "ssDNA", "max_score", "max_score_group", "length",  "hallmark",   "viral", "cellular"))

phages <- left_join(checkV_clean, VS2, by = "seqname")

######################

#Read the optional file, if it was provided
if(coord==T){
  print("Reading VS2 from round 1...")
  VS2_round1 <- fread(file_virsorter_1stRound, header = F,
                        col.names = c("seqname", "trim_orf_index_start", "trim_orf_index_end",   "trim_bp_start",   "trim_bp_end",  "trim_pr", "trim_pr_max", 
                                      "prox_orf_index_start",  "prox_orf_index_end",  "prox_bp_start",   "prox_bp_end",  "prox_pr", "prox_pr_max",
                                      "partial", "full_orf_index_start",    "full_orf_index_end",      "full_bp_start",   "full_bp_end",   "pr_full",
                                      "arc",     "bac",     "euk",     "vir",     "mix",     "unaligned",       "hallmark_cnt",    "group", 
                                      "shape",   "seqname_new",     "final_max_score", "final_max_score_group", "assembly")
  )
  #VS2_round1[, length:=trim_bp_end-trim_bp_start+1]
  VS2_round1[, contigVir:=paste(assembly, seqname_new, sep = ":")]
  
  
  #Merge  all info
  phages <- left_join(phages, VS2_round1[, c("contigVir", "trim_bp_start", "trim_bp_end")], by="contigVir") %>%
    mutate(.,
           start_inContig = ifelse(trimmed=="No", trim_bp_start, trim_bp_start+start_checkV), 
           end_inContig = ifelse(trimmed=="No", trim_bp_end, trim_bp_start+end_checkV))
  
  #Delete columns no needing anymire
  phages <- phages[, -c("trim_bp_start", "trim_bp_end")]
  
}


######################
#Calculate scores to apply filters

phages <- quality_phage_f(phages)
print(paste0(nrow(phages), " phages were annotated"))
fwrite(phages, paste0(outF, "phages_quality.tsv"), sep = "\t")

phages_filtered <- phages[length>=opt$len]

if(opt$filtering==1){
  #If at least 1 tuning removal is passed, Hegarty_removal_all<0
  #Note. Keep1 (Sullivan) is including in Hegarty_removal_all so no need to apply this
  phages_filtered <- phages_filtered[Hegarty_removal_all==0]
  fwrite(phages_filtered, paste0(outF, "phages_filtered_", opt$len, "bp_AND_3TuningRemoval.tsv"), sep = "\t")
  
  #Save a list of seqname to keep so easy to remove them from fasta
  fwrite(phages_filtered[, "seqname"], paste0(outF, "phages_filtered_", opt$len, "bp_AND_3TuningRemoval.lst"), sep = "\t", col.names = F)
  
} else{
  fwrite(phages_filtered, paste0(outF, "phages_filtered_", opt$len, "bp.tsv"), sep = "\t")
  fwrite(phages_filtered[, "seqname"], paste0(outF, "phages_filtered_", opt$len, "bp.lst"), sep = "\t", col.names = F)
  
}

print(paste0(nrow(phages_filtered), " phages passed the filter(s)"))




